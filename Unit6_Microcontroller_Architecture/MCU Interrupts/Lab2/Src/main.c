/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Platform_types.h"

//Base addresses
#define RCC_Base 				0x40021000
#define GPIO_PortA_Base 		0x40010800
#define EXTI_Base				0x40010400
#define AFIO_Base				0x40010000
#define NVIC_Base				0xE000E100

//RCC Registers
/*
 * Register Name: Clock control register (RCC_CR)
 * Address offset: 0x00
 * Reset value: 0x0000 XX83
 */
#define RCC_RC					*((vusint32_t *)(RCC_Base + 0x00))


/*
 * Register Name: Clock configuration register (RCC_CFGR)
 * Address offset: 0x04
 * Reset value: 0x0000 0000
 */
#define RCC_CFGR				*((vusint32_t *)(RCC_Base + 0x04))

/*
 * Register Name:  APB2 peripheral clock enable register (RCC_APB2ENR)
 * Address offset: 0x18
 * Reset value: 0x0000 0000
 */
#define RCC_APB2ENR 			*((vusint32_t *)(RCC_Base + 0x18))
/*
 * Bit 2: IOPAEN
 * Register: RCC_APB2ENR
 * Usage: it is used to enable clock of PortA
 * 0 >>  IO port A clock disabled
 * 1 >>  IO port A clock enabled
 * */
#define IOPAEN					2
#define AFIOEN					0		//enable clock of AFIO

//GPIO Registers
#define GPIOA_CRH 				*((vusint32_t *)(GPIO_PortA_Base + 0x04))
#define GPIOA_ODR				*((vusint32_t *)(GPIO_PortA_Base + 0x0C))
#define PIN_13					13		//output pin
#define GPIOA_CRL				*((vusint32_t *)(GPIO_PortA_Base + 0x00))
#define PIN_2					2		//input pin

//EXTI Registers
#define EXTI_IMR				*((vusint32_t *)(EXTI_Base + 0x00))
#define MR0						0		//interrupt mask for line 0
#define EXTI_RTSR				*((vusint32_t *)(EXTI_Base + 0x08))
#define TR0						0		//Rising Trigger for line 0
#define EXTI_PR					*((vusint32_t *)(EXTI_Base + 0x14))
#define PR0						0		//Pending bit 0

//AFIO Registers
#define AFIO_EXTICR1			*((vusint32_t *)(AFIO_Base + 0x08))

//NVIC Registers
#define NVIC_ISER0				*((vusint32_t *)(NVIC_Base + 0x00))
#define EXTI0					6		//EXTI line0

//Macros to set & clear & toggle specific bit
#define SET_BIT(Register,Bit_Num)		Register |= (1 << Bit_Num)
#define CLEAR_BIT(Register,Bit_Num)		Register &= (~(1 << Bit_Num))
#define TOGGLE_BIT(Register,Bit_Num)	Register ^= (1 << Bit_Num)

void Clock_Init(void);
void GPIO_Init(void);

int main(void)
{
	Clock_Init();
	GPIO_Init();

	//Configure interrupt mask register (EXTI_IMR)
	SET_BIT(EXTI_IMR,MR0);

	//Configure trigger selection (Rising or Falling) (EXTI_RTSR,EXTI_FTSR)
	SET_BIT(EXTI_RTSR,TR0);

	//Configure mask bit that control NVIC
	SET_BIT(NVIC_ISER0,EXTI0);

	//Configure AFIO_EXTICR1
	AFIO_EXTICR1 = 0x0;

	/* Loop forever */
	for(;;);
}

void Clock_Init()
{
	//open clock of GPIOA
	SET_BIT(RCC_APB2ENR,IOPAEN);

	//open clock of AFIO
	SET_BIT(RCC_APB2ENR,AFIOEN);
}

void GPIO_Init()
{
	//change mode of bits from 20 to 24 to make PortA pin13 is output pin
	GPIOA_CRH &= 0xFF0FFFFF;
	GPIOA_CRH |= 0x00200000;

	//Configure pin0 of PORTA as input
	SET_BIT(GPIOA_CRL,PIN_2);
}

/*
 * Interrupt:
 * 	>> EXTI Clock:
 * 		There is no clock for EXTI
 *
 * 	>> Hardware interrupt selection:
 * 		1) Configure interrupt mask register (EXTI_IMR)
 * 		2) Configure trigger selection (Rising or Falling) (EXTI_RTSR,EXTI_FTSR)
 * 		3) Configure mask bit that control NVIC
 *
 * 	>> External Interrupt Mapping:
 * 		we will use PA0 as EXTI0
 * 		>>> Configure AFIO_EXTICR1
 * 				>> enable clock of AFIO
 */

void EXTI0_IRQHandler(void)
{
	//toggle the led on GPIOA P13
	TOGGLE_BIT(GPIOA_ODR,PIN_13);

	//write 1 to clear pending bit
	SET_BIT(EXTI_PR,PR0);
}
