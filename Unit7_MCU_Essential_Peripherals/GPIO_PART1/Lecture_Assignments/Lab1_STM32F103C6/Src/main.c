/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Platform_types.h"

//Base addresses
#define RCC_Base 				0x40021000
#define GPIO_PortA_Base 		0x40010800
#define GPIO_PortB_Base			0x40010C00

//RCC Registers
/*
 * Register Name:  APB2 peripheral clock enable register (RCC_APB2ENR)
 * Address offset: 0x18
 * Reset value: 0x0000 0000
 */
#define RCC_APB2ENR 			*((vusint32_t *)(RCC_Base + 0x18))
/*
 * Bit 2: IOPAEN
 * Register: RCC_APB2ENR
 * Usage: it is used to enable clock of PortA
 * 0 >>  IO port A clock disabled
 * 1 >>  IO port A clock enabled
 * */
#define IOPAEN					2
#define IOPBEN					3

//GPIOA Registers
#define GPIOA_CRL				*((vusint32_t *)(GPIO_PortA_Base + 0x00))
#define GPIOA_CRH 				*((vusint32_t *)(GPIO_PortA_Base + 0x04))
#define GPIOA_IDR				*((vusint32_t *)(GPIO_PortA_Base + 0x08))
#define GPIOA_ODR				*((vusint32_t *)(GPIO_PortA_Base + 0x0C))

//GPIOB Registers
#define GPIOB_CRL				*((vusint32_t *)(GPIO_PortB_Base + 0x00))
#define GPIOB_CRH 				*((vusint32_t *)(GPIO_PortB_Base + 0x04))
#define GPIOB_IDR				*((vusint32_t *)(GPIO_PortB_Base + 0x08))
#define GPIOB_ODR				*((vusint32_t *)(GPIO_PortB_Base + 0x0C))

//Pins
#define PINB_1					1
#define PINB_13					13


//Macros to set & clear & toggle specific bit
#define SET_BIT(Register,Bit_Num)		Register |= (1 << Bit_Num)
#define CLEAR_BIT(Register,Bit_Num)		Register &= (~(1 << Bit_Num))
#define TOGGLE_BIT(Register,Bit_Num)	Register ^= (1 << Bit_Num)

void Clock_Init(void);
void GPIO_Init(void);
void __delay__(usint32_t x);

int main(void)
{
	Clock_Init();
	GPIO_Init();

	/* Loop forever */
	while(1)
	{
		if(((GPIOA_IDR & (1<<1)) >> 1) == 0)
		{
			TOGGLE_BIT(GPIOB_ODR,1);
			while(((GPIOA_IDR & (1<<1)) >> 1) == 0); //single press
		}

		if(((GPIOA_IDR & (1<<13)) >> 13) == 1)
		{
			TOGGLE_BIT(GPIOB_ODR,13);	//multi press
		}

		__delay__(1);
	}
}

void Clock_Init()
{
	//open clock of GPIOA
	SET_BIT(RCC_APB2ENR,IOPAEN);

	//open clock of GPIOB
	SET_BIT(RCC_APB2ENR,IOPBEN);
}

void GPIO_Init()
{
	GPIOA_CRL = 0x0;
	GPIOA_CRH = 0x0;

	//PA1: (Mode >> Input mode(00)) (CNF >>  Floating input(01))
	GPIOA_CRL |= (0b00 << 4);
	GPIOA_CRL |= (0b01 << 6);

	//PA13: (Mode >> Input mode(00)) (CNF >>  Floating input(01))
	GPIOA_CRH |= (0b00 << 20);
	GPIOA_CRH |= (0b01 << 22);

	GPIOB_CRL = 0x0;
	GPIOB_CRH = 0x0;

	//PB1: (Mode >> Output mode, max speed 10 MHz(01)) (CNF >> General purpose output push-pull(00))
	GPIOB_CRL |= (0b01 << 4);
	GPIOB_CRL |= (0b00 << 6);

	//Pin13: (Mode >> Output mode, max speed 10 MHz(01)) (CNF >> General purpose output push-pull(00))
	GPIOB_CRH |= (0b01 << 20);
	GPIOB_CRH |= (0b00 << 22);
}

void __delay__(usint32_t x)
{
	usint32_t i, j;

	for(i = 0; i < x; i++)
		for(j = 0; j < 255; j++);
}
