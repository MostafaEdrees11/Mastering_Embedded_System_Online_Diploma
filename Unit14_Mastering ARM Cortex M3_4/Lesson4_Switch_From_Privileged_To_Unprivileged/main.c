/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Mostafa Edrees
 * @brief          : Lab1 on ARM Modes for Lesson2 on Unit14 (Mastering ARM Cortex-M3/4)
 * @date           : 14/2/2024
 * @board          : STM32F103C8T6
 * @processor      : ARM Cortex M3
 ******************************************************************************
 **/

#include "STM32F103x8.h"
#include "STM32F103x8_GPIO_Driver.h"
#include "STM32F103x8_EXTI_Driver.h"

void NMI_Handler()
{

}

void HardFault_Handler()
{

}

void MemManage_Handler()
{

}

void BusFault_Handler()
{

}
int IRQ_Flag = 0;

enum CPU_ACCESS_LEVEL
{
	privileged,
	unprivileged
};

void SWITCH_CPU_ACCESS_LEVEL(enum CPU_ACCESS_LEVEL CPU_STATE)
{
	switch(CPU_STATE)
	{
	case privileged:
		// Clear Bit0 @ Control Register
		__asm("MRS R3, CONTROL	\n\t"	//Move control register to general purpose register 'r3'
			  "LSR R3, R3, #1	\n\t"	//Shift R3 to right by one	ex:  0b00010001 --> 0b00001000
			  "LSL R3, R3, #1	\n\t"	//Shift R3 to left by one	--> 0b00010000 --> we clear the bit
			  "MSR CONTROL, R3");		//Move the value of R3 after clear the bit to control register
		break;

	case unprivileged:
		// Set Bit0 @ Control Register
		__asm("MRS R3, CONTROL	\n\t"	//Move control register to general purpose register 'r3'
			  "ORR R3, R3, #0x1 \n\t"	//Logical or between R3 and 0x1 to set the first bit
			  "MSR CONTROL, R3");		//Move the value of R3 after clear the bit to control register
		break;
	}
}

void EXTI9_CallBack(void)
{
	IRQ_Flag = 1;

	//SWITCH_CPU_ACCESS_LEVEL(privileged);
}

int main(void)
{
	RCC_AFIO_CLK_EN();
	RCC_GPIOB_CLK_EN();

	SWITCH_CPU_ACCESS_LEVEL(unprivileged);

	EXTI_Configuration_t EXTI_config;
	EXTI_config.EXTI_PIN = EXTI9PB9;
	EXTI_config.EXTI_Trigger_Case = EXTI_Trigger_RISING;
	EXTI_config.PF_IRQ_CallBack = EXTI9_CallBack;
	EXTI_config.EXTI_IRQ_EN = EXTI_IRQ_ENABLE;
	MCAL_EXTI_GPIO_Init(&EXTI_config);

	//SWITCH_CPU_ACCESS_LEVEL(unprivileged);
	//SWITCH_CPU_ACCESS_LEVEL(privileged);

	/* Loop forever */
	while(1)
	{
		if(IRQ_Flag)
		{
			IRQ_Flag = 0;
		}
		else
		{

		}
	}
}
